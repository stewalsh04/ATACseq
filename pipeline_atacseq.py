"""===========================
Pipeline template
===========================

.. Replace the documentation below with your own description of the
   pipeline's purpose

Overview
========

This pipeline computes the word frequencies in the configuration
files :file:``pipeline.yml` and :file:`conf.py`.

Usage
=====

See :ref:`PipelineSettingUp` and :ref:`PipelineRunning` on general
information how to use CGAT pipelines.

Configuration
-------------

The pipeline requires a configured :file:`pipeline.yml` file.
CGATReport report requires a :file:`conf.py` and optionally a
:file:`cgatreport.ini` file (see :ref:`PipelineReporting`).

Default configuration files can be generated by executing:

   python <srcdir>/pipeline_atacseq.py config

Input files
-----------

None required except the pipeline configuration files.

Requirements
------------

The pipeline requires the results from
:doc:`pipeline_genesets`. Set the configuration variable
:py:data:`annotations_database` and :py:data:`annotations_dir`.

On top of the default CGAT setup, the pipeline requires the following
software to be in the path:

.. Add any additional external requirements such as 3rd party software
   or R modules below:

Requirements:

* samtools >= 1.1

Pipeline output
===============

.. Describe output files of the pipeline here

Glossary
========

.. glossary::


Code
====

"""
import sys
import os
from ruffus import *
from CGATCore import Pipeline as P


# load options from the config file
PARAMS = P.get_parameters(
    ["%s/pipeline.yml" % os.path.splitext(__file__)[0],
     "../pipeline.yml",
     "pipeline.yml"])
    
#inputs = ['mm_ATACCT8LightPulse60v1v2_R3_filtered.bam',
#'mm_ATACCT8LightPulse60v1v2_R4_filtered.bam']

# Specific pipeline tasks
@transform('*.bam',
           suffix(".bam"),
           "_atacqc.html")
def atac_qc(infile, outfile):
    '''Perform atac qc on bam files.'''
    
    cwd = os.getcwd()
    # the command line statement we want to execute
    
    statement = '''R -e "rmarkdown::render('/ifs/projects/proj078/1_atac_seq/SteveW_Rproject/atac_qc_run.Rmd',
    output_file='%(cwd)s/%(outfile)s')" --args "%(cwd)s/%(infile)s" "%(cwd)s/"''' % locals()
    
    P.run(statement)

@merge(('*.bam',
       suffix(".bam")),
       "_counts.csv")
def atac_counting(infiles, outfile):
     '''Read counting with rsubread'''
     
     cwd = os.getcwd()
     peak_file =  PARAMS['peak_file_gtf']
     infiles2 = []
     
     for x in infiles:
         infiles2.append(x)
     
     length = len(infiles2)
     
     for x in range(length):
         infiles2[x] = cwd + "/" + str(infiles2[x])
         print (infiles2[x])
     
     infiles2. pop()
     infile_str = ','.join(infiles2)                   
     
     statement = '''R -e "rmarkdown::render('/ifs/projects/proj078/1_atac_seq/SteveW_Rproject/rsubread_multiple.Rmd',output_file='%(cwd)s/rsubread.htm')"  
     --args "%(infile_str)s"  "%(peak_file)s" "%(cwd)s/"''' % locals()
     
     P.run(statement)

@transform('*_counts.csv',
       suffix("_counts.csv"),
       "deseq.html")
def atac_deseq(infile, outfile):
    ''''Differential anlaysis with deseq'''
    
    cwd = os.getcwd()
    sample_sheet = PARAMS['sample_sheet']
    peak_file =  PARAMS['peak_file']
    gene = PARAMS['gene']
    
    statement = '''R -e "rmarkdown::render('/ifs/projects/proj078/1_atac_seq/SteveW_Rproject/DEseq2_run_new1.Rmd',output_file='%(cwd)s/deseq.htm')"  
     --args "%(cwd)s/%(infile)s" "%(sample_sheet)s" "%(peak_file)s" "%(gene)s"''' % locals()
     
    P.run(statement)

@transform('*_counts.csv',
       suffix("_counts.csv"),
       "deseq_pca.html")
def atac_deseq_pca(infile, outfile):
    ''''PCA anlaysis with deseq'''
    
    cwd = os.getcwd()
    sample_sheet = PARAMS['sample_sheet']
    
    statement = '''R -e "rmarkdown::render('/ifs/projects/proj078/1_atac_seq/SteveW_Rproject/DEseq_pca.Rmd',output_file='%(cwd)s/deseq_pca.htm')"  
     --args "%(cwd)s/%(infile)s" "%(sample_sheet)s"''' % locals()
     
    P.run(statement)
    
  # ---------------------------------------------------
  #Generic pipeline tasks
#@follows(atac_qc)
#def full():
#    pass
# 
# 
def main(argv=None):
    if argv is None:
        argv = sys.argv
    P.main(argv)
# 
# 
if __name__ == "__main__":
    sys.exit(P.main(sys.argv))    
# 
# =============================================================================
